<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extension Context Recovery Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f7;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
        }
        
        h1 {
            color: #1d1d1f;
            margin-bottom: 10px;
        }
        
        .status {
            padding: 12px 16px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
        }
        
        .status.success {
            background-color: #d1edff;
            color: #0c5460;
            border: 1px solid #b3e0ff;
        }
        
        .status.error {
            background-color: #ffd6d6;
            color: #c41e3a;
            border: 1px solid #ffb3b3;
        }
        
        .status.warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .status.info {
            background-color: #e7f3ff;
            color: #004085;
            border: 1px solid #b3d9ff;
        }
        
        .test-section {
            margin: 25px 0;
            padding: 20px;
            background: #fafafa;
            border-radius: 8px;
            border: 1px solid #e1e1e1;
        }
        
        .test-section h3 {
            margin-top: 0;
            color: #333;
        }
        
        button {
            background: #007aff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .log-area {
            background: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 6px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 12px;
            line-height: 1.4;
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        
        .stat-title {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #007aff;
            width: 0;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Extension Context Recovery Test</h1>
        <p>Test the enhanced extension communication with context invalidation recovery.</p>
        
        <div id="initial-status" class="status info">
            ‚è≥ Initializing extension communication tests...
        </div>

        <!-- Extension Status Section -->
        <div class="test-section">
            <h3>üìä Extension Status</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-title">Context State</div>
                    <div class="stat-value" id="context-state">Unknown</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Queue Size</div>
                    <div class="stat-value" id="queue-size">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Recovery State</div>
                    <div class="stat-value" id="recovery-state">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Success Rate</div>
                    <div class="stat-value" id="success-rate">-</div>
                </div>
            </div>
            <button onclick="updateExtensionStatus()">üîÑ Refresh Status</button>
        </div>

        <!-- Basic Communication Tests -->
        <div class="test-section">
            <h3>üîÑ Basic Communication Tests</h3>
            <p>Test basic PING communication with the extension background script.</p>
            
            <button onclick="testBasicPing()">üèì Test Basic PING</button>
            <button onclick="testPingExtension()">üèì Test PING_EXTENSION</button>
            <button onclick="testWebAppPing()">üí¨ Test Web App Communication</button>
            
            <div id="basic-test-results"></div>
        </div>

        <!-- Context Recovery Tests -->
        <div class="test-section">
            <h3>üîÑ Context Recovery Tests</h3>
            <p>Test extension communication recovery after context invalidation.</p>
            
            <div class="status warning">
                ‚ö†Ô∏è <strong>Instructions:</strong> To test context recovery, reload the extension in Chrome (chrome://extensions, click reload) while tests are running.
            </div>
            
            <button onclick="startRecoveryTest()">üöÄ Start Recovery Test</button>
            <button onclick="simulateContextInvalidation()" style="background: #ff9500;">‚ö° Simulate Context Loss</button>
            <button onclick="stopRecoveryTest()" style="background: #ff3b30;">‚èπÔ∏è Stop Test</button>
            
            <div class="progress-bar">
                <div class="progress-fill" id="recovery-progress"></div>
            </div>
            
            <div id="recovery-test-results"></div>
        </div>

        <!-- Message Queue Tests -->
        <div class="test-section">
            <h3>üì¶ Message Queue Tests</h3>
            <p>Test message queuing and retry logic during context issues.</p>
            
            <button onclick="testMessageQueue()">üì§ Test Message Queuing</button>
            <button onclick="floodTest()">üåä Flood Test (10 messages)</button>
            <button onclick="clearMessageQueue()">üóëÔ∏è Clear Queue</button>
            
            <div id="queue-test-results"></div>
        </div>

        <!-- Debug Console -->
        <div class="test-section">
            <h3>üîç Debug Console</h3>
            <div class="log-area" id="debug-console"></div>
            <button onclick="clearDebugConsole()">üóëÔ∏è Clear Console</button>
        </div>
    </div>

    <!-- Load the MessageQueueManager -->
    <script src="utils/MessageQueueManager.js"></script>
    <!-- Load the test communication script -->
    <script src="test-communication.js"></script>
    
    <script>
        let recoveryTestInterval = null;
        let recoveryTestStartTime = null;
        let messagesSent = 0;
        let messagesSucceeded = 0;
        
        // Debug logging function
        function debugLog(message, type = 'info') {
            const console_el = document.getElementById('debug-console');
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                info: '#00ff00',
                warn: '#ffff00', 
                error: '#ff5555',
                success: '#00ffaa'
            };
            
            const logEntry = `<div style="color: ${colors[type] || colors.info};">[${timestamp}] ${message}</div>`;
            console_el.innerHTML += logEntry;
            console_el.scrollTop = console_el.scrollHeight;
            
            // Also log to browser console
            console.log(`[Context Recovery Test] ${message}`);
        }
        
        // Clear debug console
        function clearDebugConsole() {
            document.getElementById('debug-console').innerHTML = '';
        }
        
        // Update extension status
        async function updateExtensionStatus() {
            debugLog('Updating extension status...', 'info');
            
            try {
                if (typeof MessageQueueManager !== 'undefined') {
                    const queueManager = new MessageQueueManager();
                    const stats = queueManager.getStats();
                    
                    document.getElementById('context-state').textContent = 
                        stats.validationCache.isValid ? 'VALID' : 'INVALID';
                    document.getElementById('queue-size').textContent = stats.queueSize;
                    document.getElementById('recovery-state').textContent = stats.recoveryState.state;
                    document.getElementById('success-rate').textContent = stats.successRate;
                    
                    debugLog(`Extension Status: ${JSON.stringify({
                        context: stats.validationCache.isValid ? 'VALID' : 'INVALID',
                        queue: stats.queueSize,
                        recovery: stats.recoveryState.state,
                        success: stats.successRate
                    })}`, 'success');
                } else {
                    debugLog('MessageQueueManager not available', 'error');
                }
            } catch (error) {
                debugLog(`Status update failed: ${error.message}`, 'error');
            }
        }
        
        // Test basic PING
        async function testBasicPing() {
            debugLog('Testing basic PING...', 'info');
            const resultsDiv = document.getElementById('basic-test-results');
            
            try {
                if (typeof MessageQueueManager !== 'undefined') {
                    const queueManager = new MessageQueueManager();
                    const isValid = await queueManager.validateContext();
                    
                    resultsDiv.innerHTML = `<div class="status ${isValid ? 'success' : 'error'}">
                        Basic PING: ${isValid ? '‚úÖ SUCCESS' : '‚ùå FAILED'}
                    </div>`;
                    
                    debugLog(`Basic PING result: ${isValid ? 'SUCCESS' : 'FAILED'}`, isValid ? 'success' : 'error');
                } else {
                    throw new Error('MessageQueueManager not available');
                }
            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Basic PING failed: ${error.message}</div>`;
                debugLog(`Basic PING error: ${error.message}`, 'error');
            }
        }
        
        // Test PING_EXTENSION
        async function testPingExtension() {
            debugLog('Testing PING_EXTENSION...', 'info');
            const resultsDiv = document.getElementById('basic-test-results');
            
            try {
                if (typeof MessageQueueManager !== 'undefined') {
                    const queueManager = new MessageQueueManager();
                    const response = await queueManager.enqueue({ type: 'PING_EXTENSION' });
                    
                    const success = response?.success === true;
                    resultsDiv.innerHTML += `<div class="status ${success ? 'success' : 'error'}">
                        PING_EXTENSION: ${success ? '‚úÖ SUCCESS' : '‚ùå FAILED'} - ${JSON.stringify(response)}
                    </div>`;
                    
                    debugLog(`PING_EXTENSION result: ${success ? 'SUCCESS' : 'FAILED'} - ${JSON.stringify(response)}`, success ? 'success' : 'error');
                } else {
                    throw new Error('MessageQueueManager not available');
                }
            } catch (error) {
                resultsDiv.innerHTML += `<div class="status error">‚ùå PING_EXTENSION failed: ${error.message}</div>`;
                debugLog(`PING_EXTENSION error: ${error.message}`, 'error');
            }
        }
        
        // Test Web App communication
        async function testWebAppPing() {
            debugLog('Testing Web App communication...', 'info');
            const resultsDiv = document.getElementById('basic-test-results');
            
            return new Promise((resolve) => {
                const testId = `webapp_test_${Date.now()}`;
                let responseReceived = false;
                
                // Listen for response
                const responseHandler = (event) => {
                    if (event.data?.type === 'EXTENSION_PONG' && !responseReceived) {
                        responseReceived = true;
                        window.removeEventListener('message', responseHandler);
                        
                        resultsDiv.innerHTML += `<div class="status success">
                            ‚úÖ Web App Communication: SUCCESS - ${JSON.stringify(event.data)}
                        </div>`;
                        
                        debugLog(`Web App communication SUCCESS: ${JSON.stringify(event.data)}`, 'success');
                        resolve(true);
                    }
                };
                
                window.addEventListener('message', responseHandler);
                
                // Send test message
                window.postMessage({
                    type: 'EXTENSION_PING',
                    messageId: testId,
                    payload: { test: true, timestamp: Date.now() },
                    source: 'context-recovery-test'
                }, '*');
                
                debugLog(`Sent Web App PING with ID: ${testId}`, 'info');
                
                // Timeout after 5 seconds
                setTimeout(() => {
                    if (!responseReceived) {
                        window.removeEventListener('message', responseHandler);
                        resultsDiv.innerHTML += `<div class="status error">
                            ‚ùå Web App Communication: TIMEOUT
                        </div>`;
                        debugLog('Web App communication TIMEOUT', 'error');
                        resolve(false);
                    }
                }, 5000);
            });
        }
        
        // Start recovery test
        function startRecoveryTest() {
            debugLog('Starting context recovery test...', 'info');
            const resultsDiv = document.getElementById('recovery-test-results');
            
            if (recoveryTestInterval) {
                clearInterval(recoveryTestInterval);
            }
            
            recoveryTestStartTime = Date.now();
            messagesSent = 0;
            messagesSucceeded = 0;
            
            // Test every 2 seconds
            recoveryTestInterval = setInterval(async () => {
                messagesSent++;
                const elapsed = Math.round((Date.now() - recoveryTestStartTime) / 1000);
                
                try {
                    if (typeof MessageQueueManager !== 'undefined') {
                        const queueManager = new MessageQueueManager();
                        const response = await queueManager.enqueue({ 
                            type: 'PING_EXTENSION',
                            testId: `recovery_test_${messagesSent}`,
                            timestamp: Date.now()
                        });
                        
                        if (response?.success) {
                            messagesSucceeded++;
                            debugLog(`Recovery test message ${messagesSent}: SUCCESS`, 'success');
                        } else {
                            debugLog(`Recovery test message ${messagesSent}: FAILED - ${JSON.stringify(response)}`, 'error');
                        }
                    }
                } catch (error) {
                    debugLog(`Recovery test message ${messagesSent}: ERROR - ${error.message}`, 'error');
                }
                
                // Update progress and results
                const successRate = messagesSent > 0 ? Math.round((messagesSucceeded / messagesSent) * 100) : 0;
                const progressPercent = Math.min((elapsed / 60) * 100, 100); // 60 seconds max
                
                document.getElementById('recovery-progress').style.width = `${progressPercent}%`;
                
                resultsDiv.innerHTML = `
                    <div class="status info">
                        üìä Recovery Test Status:<br>
                        ‚Ä¢ Messages Sent: ${messagesSent}<br>
                        ‚Ä¢ Messages Succeeded: ${messagesSucceeded}<br>
                        ‚Ä¢ Success Rate: ${successRate}%<br>
                        ‚Ä¢ Elapsed: ${elapsed}s
                    </div>
                `;
                
                // Update extension status
                await updateExtensionStatus();
                
                // Stop after 2 minutes
                if (elapsed > 120) {
                    stopRecoveryTest();
                }
                
            }, 2000);
            
            debugLog('Context recovery test started (will run for 2 minutes)', 'success');
        }
        
        // Stop recovery test
        function stopRecoveryTest() {
            if (recoveryTestInterval) {
                clearInterval(recoveryTestInterval);
                recoveryTestInterval = null;
                debugLog('Context recovery test stopped', 'info');
                
                document.getElementById('recovery-progress').style.width = '0%';
            }
        }
        
        // Simulate context invalidation
        function simulateContextInvalidation() {
            debugLog('Simulating context invalidation...', 'warn');
            
            if (typeof MessageQueueManager !== 'undefined') {
                const queueManager = new MessageQueueManager();
                // Force validation cache to be invalid
                queueManager.validationCache.isValid = false;
                queueManager.validationCache.lastChecked = 0;
                queueManager.recoveryState.state = 'RECOVERING';
                
                debugLog('Context invalidation simulated - cache cleared', 'warn');
            } else {
                debugLog('Cannot simulate - MessageQueueManager not available', 'error');
            }
        }
        
        // Test message queue
        async function testMessageQueue() {
            debugLog('Testing message queue functionality...', 'info');
            const resultsDiv = document.getElementById('queue-test-results');
            
            try {
                if (typeof MessageQueueManager !== 'undefined') {
                    const queueManager = new MessageQueueManager();
                    
                    // Send multiple messages quickly
                    const promises = [];
                    for (let i = 1; i <= 5; i++) {
                        promises.push(queueManager.enqueue({
                            type: 'PING_EXTENSION',
                            testId: `queue_test_${i}`,
                            messageNum: i
                        }));
                    }
                    
                    const results = await Promise.allSettled(promises);
                    const successful = results.filter(r => r.status === 'fulfilled' && r.value?.success).length;
                    
                    resultsDiv.innerHTML = `<div class="status ${successful > 0 ? 'success' : 'error'}">
                        üì¶ Message Queue Test: ${successful}/5 messages succeeded
                    </div>`;
                    
                    debugLog(`Message queue test: ${successful}/5 messages succeeded`, successful > 0 ? 'success' : 'error');
                } else {
                    throw new Error('MessageQueueManager not available');
                }
            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">‚ùå Queue test failed: ${error.message}</div>`;
                debugLog(`Message queue test error: ${error.message}`, 'error');
            }
        }
        
        // Flood test
        async function floodTest() {
            debugLog('Starting flood test (10 messages)...', 'info');
            const resultsDiv = document.getElementById('queue-test-results');
            
            try {
                if (typeof MessageQueueManager !== 'undefined') {
                    const queueManager = new MessageQueueManager();
                    
                    // Send 10 messages quickly
                    const promises = [];
                    for (let i = 1; i <= 10; i++) {
                        promises.push(queueManager.enqueue({
                            type: 'PING_EXTENSION',
                            testId: `flood_test_${i}`,
                            messageNum: i,
                            timestamp: Date.now()
                        }));
                    }
                    
                    const startTime = Date.now();
                    const results = await Promise.allSettled(promises);
                    const endTime = Date.now();
                    
                    const successful = results.filter(r => r.status === 'fulfilled' && r.value?.success).length;
                    const duration = endTime - startTime;
                    
                    resultsDiv.innerHTML += `<div class="status ${successful > 0 ? 'success' : 'error'}">
                        üåä Flood Test: ${successful}/10 messages succeeded in ${duration}ms
                    </div>`;
                    
                    debugLog(`Flood test: ${successful}/10 messages succeeded in ${duration}ms`, successful > 0 ? 'success' : 'error');
                } else {
                    throw new Error('MessageQueueManager not available');
                }
            } catch (error) {
                resultsDiv.innerHTML += `<div class="status error">‚ùå Flood test failed: ${error.message}</div>`;
                debugLog(`Flood test error: ${error.message}`, 'error');
            }
        }
        
        // Clear message queue
        function clearMessageQueue() {
            debugLog('Clearing message queue...', 'info');
            
            if (typeof MessageQueueManager !== 'undefined') {
                const queueManager = new MessageQueueManager();
                queueManager.clearQueue('Manual clear requested');
                debugLog('Message queue cleared', 'success');
                updateExtensionStatus();
            } else {
                debugLog('Cannot clear queue - MessageQueueManager not available', 'error');
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            debugLog('Context Recovery Test initialized', 'success');
            
            // Wait a moment for extension to initialize
            setTimeout(async () => {
                await updateExtensionStatus();
                
                const statusDiv = document.getElementById('initial-status');
                statusDiv.className = 'status success';
                statusDiv.innerHTML = '‚úÖ Extension communication tests ready! Use the buttons above to test recovery functionality.';
                
                debugLog('All test functions loaded and ready', 'success');
            }, 1000);
        });
    </script>
</body>
</html>